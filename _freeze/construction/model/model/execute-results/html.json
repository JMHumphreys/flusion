{
  "hash": "fe1b61df817a2e89c0ed796160590f58",
  "result": {
    "markdown": "---\ntitle: \"Model Inference\"\ndescription: \"Constructing formula and running the model.\"\nformat:\n  html:\n    df-print: kable\n    code-fold: show\n    code-summary: \"Hide code\"\n    code-overflow: wrap\n    toc-title: Page Contents\n    toc: true\n    toc-depth: 2\n    toc-location: right\n    number-sections: false\n    html-math-method: katex\n    css: styles.css\n    theme: flatly\n    smooth-scroll: true\neditor_options: \n  chunk_output_type: console\n---\n\n```{=html}\n<style type=\"text/css\">\n\nbody, td {\n   font-size: 13pt;\n}\ncode.r{\n  font-size: 9pt;\n}\npre {\n  font-size: 11pt\n}\n</style>\n```\n\n# Overview\n\nHaving completed data preprocessing and data organization, a formula is constructed and the model run.\n\n**Note:** This script requires that both the data [**Preprocessing**](https://jmhumphreys.github.io/flusion/construction/preprocessing/preprocessing.html) and the [**Data Organization**](https://jmhumphreys.github.io/flusion/construction/organize/organize.html) have already been completed with all resulting objects available in the working environment.\n\n\n::: {.cell}\n\n:::\n\n\n# Prior Specifications\n\n::: {.cell}\n\n```{.r .cell-code}\ninla.setOption(inla.mode= \"experimental\")\n\n#Besag-Mollie-York\nbym_hyper <- list(\n    prec = list(\n        initial = 2, \n        prior = \"pc.prec\",\n        param = c(0.6, 0.01)),\n    phi = list(\n        initial = 2, \n        prior = \"pc\",\n        param = c(0.5, 0.5)))\n\n#iid prior\npc_prec_iid <- list(theta = list(prior=\"pc.prec\", \n                                 param=c(1, 0.01)))\n\n#ar1 prior\npc_cor_ar1 <- list(theta = list(prior = 'pccor1', \n                                param = c(0.7, 0.5)))\n\n#rw prior\npcprior1 = list(prec = list(prior=\"pc.prec\", \n                            param = c(1, 0.01)))\n```\n:::\n\n\n# Joint Model Formula  \n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.1 = Y ~ -1 + intercept1 + #intercept for ILI submodel\n                 intercept2 + #intercept for NREVSS submodel\n                 intercept3 + #intercept for HHS submodel\n                   l.pop.ili + #log-population: could have been combined, but\n                   l.pop.nv +  #wanted to see if effect differd   \n                   l.pop.hhs + #by submodel\n                      f(Region.1.ili, # location index specific to ILI submodel\n                         model=\"bym2\", #Besag-Mollie-York model (spatial + region IID)\n                         graph=J,      #neighborhood adjacency matrix\n                         constr=TRUE,  #enforce a zero-mean latent field\n                         group = year.ili, #Annual time steps,year-specific spatial fields\n                         control.group=list(model=\"ar1\"), #order-1 autoregressive between annual fields\n                         hyper=bym_hyper) + #prior\n                      f(Region.1.nv,   # As above but specific to NREVSS submodel\n                         model=\"bym2\",\n                         graph=J,\n                         constr=TRUE,\n                         group = year.nv.1, \n                         control.group=list(model=\"ar1\"),\n                         hyper=bym_hyper) + \n                      f(Region.2.nv,   # Create a copy of ILI BYM model, and share it with NREVSS submodel\n                         copy=\"Region.1.ili\", #what to copy\n                         group = year.nv.2,\n                         fixed=FALSE) +\n                      f(Region.1.hhs,  # Besag-Mollie-York model specific to HHS submodel\n                         model=\"bym2\", #as above\n                         graph=J,\n                         constr=TRUE, \n                         group = year.hhs.1,\n                         control.group=list(model=\"ar1\"),\n                         hyper=bym_hyper) + \n                      f(Region.2.hhs, # Create a copy of ILI BYM model, and share it with HHS submodel\n                         copy=\"Region.1.ili\",\n                         group = year.hhs.2,\n                         fixed=FALSE) +\n                      f(Region.3.hhs,  # Create a copy of NREVSS BYM model, and share it with HHS submodel\n                         copy=\"Region.1.nv\",\n                         group = year.hhs.3,\n                         fixed=FALSE) + \n                      f(ts_week.1.nv, # Use model etimates from NREVSS submodel to identify seasonality          \n                         constr=TRUE,\n                         scale.model = TRUE,\n                         model=\"seasonal\",\n                         season.length = 52, #guess at how many weeks between seasonal cycles\n                         hyper=pcprior1) +\n                      f(ts_week.2.nv,       # IID term to account for variation outside of          \n                         constr=TRUE,        # seasonal effect above\n                         model=\"iid\",\n                         hyper=pc_prec_iid) +\n                      f(ts_week.c,          #  copy seasonal effect to HHS submodel\n                         copy = \"ts_week.1.nv\",\n                         fixed=FALSE) +\n                      f(ts_week.iid.c,      #  copy IID extra-seasonal effect to HHS submodel\n                         copy = \"ts_week.2.nv\",\n                         fixed=FALSE) +\n                      f(ts_week.fs, en_est.s, # perform order-2 random walk across all levels based         \n                         constr=TRUE,      # on the temporal pattern exhibited by the FluSurv data\n                         scale.model = TRUE,\n                         model=\"rw2\",\n                         hyper=pcprior1) +\n                     f(st_int.nv,         #NREVSS space-time interaction (location-week)      \n                        constr=TRUE,\n                        model=\"iid\",\n                        hyper=pc_prec_iid) +\n                     f(st_int.c,          #copy NREVSS space-time interaction to HHS level\n                        copy = \"st_int.nv\",\n                        fixed=FALSE)\n```\n:::\n\n\n# Hyperparameter Estimates  \nMean estimates for all 22 model hyperparameters.  These were estimated in advance by running a smaller, 5yr model.\n\n::: {.cell}\n\n```{.r .cell-code}\ntheta8 = c(0.681697728, -0.492510866, -2.058167639, 0.006865191, -1.002600890, 2.926536468, -0.321834109, 0.153080825, 1.959042282,\n           -1.832427192, -1.118539999, 1.942998892, 3.403507238, -1.016877442, -3.634452225, -0.407023837, -0.023686173,\n           0.529309680, 0.332056118, 0.999033065, 0.857719181, 0.528751714)\n```\n:::\n\n\n# Run Model \n\n::: {.cell}\n\n```{.r .cell-code}\nJoint.mod = inla(Frm.1, #formula from above\n      \t\t\t\t num.threads = 8, #cores to use\n      \t\t\t\t data = inla.stack.data(joint_stack), # combined DataStack with substacks for all submodels\n      \t\t\t\t family = c(\"gaussian\", \"gaussian\",\"gaussian\"), #responses are normal\n      \t\t\t\t verbose = TRUE, # print run process to screen\n      \t\t\t\t control.fixed = list(prec = 1, # proper intercept\n      \t\t\t\t\t\t\t\t\t  prec.intercept = 1), \n      \t\t\t\t control.predictor = list(\n      \t\t\t\t\t\t\t\t\t\t\t A = inla.stack.A(joint_stack), \n      \t\t\t\t\t\t\t\t\t compute = TRUE, # include fitted values\n      \t\t\t\t\t\t\t\t\t\t  link = 1), #default link function settings\n      \t\t\t\t control.mode = list(restart = TRUE, theta = theta8), #initial values above\n      \t\t\t\t control.inla = list(strategy=\"gaussian\", #strategy to speed up\n      \t\t\t\t\t\t\t\t\t\t\t       int.strategy = \"eb\"), #empirical Bayes (based on modes)\n      \t\t\t\t control.compute=list(dic = F, cpo = F, waic = F)) # these just slow the run down\n\n#save resulting model and inputs  \n#save(list=c(\"Joint.mod\", \"J\", \"joint_stack\"), file=\"./data/runs/model-2023-06-09.RData\", version = 2)\n```\n:::\n",
    "supporting": [
      "model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}